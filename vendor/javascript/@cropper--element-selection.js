import t from"@cropper/element";import{EVENT_CHANGE as e,on as i,EVENT_KEYDOWN as s,off as a,isPositiveNumber as h,CROPPER_CANVAS as n,getAdjustedSizes as o,EVENT_ACTION_START as r,EVENT_ACTION_END as c,EVENT_ACTION as l,CROPPER_SELECTION as d,ACTION_SELECT as f,ACTION_SCALE as $,getOffset as u,ACTION_MOVE as v,ACTION_RESIZE_SOUTHEAST as p,ACTION_RESIZE_SOUTHWEST as m,ACTION_RESIZE_NORTHWEST as g,ACTION_RESIZE_NORTHEAST as b,ACTION_RESIZE_WEST as w,ACTION_RESIZE_EAST as y,ACTION_RESIZE_SOUTH as k,ACTION_RESIZE_NORTH as A,isNumber as C,isPlainObject as S,CROPPER_IMAGE as x,isFunction as D}from"@cropper/utils";var E=':host{display:block;left:0;position:relative;right:0}:host([outlined]){outline:1px solid var(--theme-color)}:host([multiple]){outline:1px dashed hsla(0,0%,100%,.5)}:host([multiple]):after{bottom:0;content:"";cursor:pointer;display:block;left:0;position:absolute;right:0;top:0}:host([multiple][active]){outline-color:var(--theme-color);z-index:1}:host([multiple])>*{visibility:hidden}:host([multiple][active])>*{visibility:visible}:host([multiple][active]):after{display:none}';const N=new WeakMap;class CropperSelection extends t{constructor(){super(...arguments);this.$onCanvasAction=null;this.$onCanvasActionStart=null;this.$onCanvasActionEnd=null;this.$onDocumentKeyDown=null;this.$action="";this.$actionStartTarget=null;this.$style=E;this.x=0;this.y=0;this.width=0;this.height=0;this.aspectRatio=NaN;this.initialAspectRatio=NaN;this.initialCoverage=NaN;this.active=false;this.movable=false;this.resizable=false;this.zoomable=false;this.multiple=false;this.keyboard=false;this.outlined=false;this.precise=false}set $canvas(t){N.set(this,t)}get $canvas(){return N.get(this)}static get observedAttributes(){return super.observedAttributes.concat(["active","aspect-ratio","height","initial-aspect-ratio","initial-coverage","keyboard","movable","multiple","outlined","precise","resizable","width","x","y","zoomable"])}$propertyChangedCallback(t,n,o){if(!Object.is(o,n)){super.$propertyChangedCallback(t,n,o);switch(t){case"aspectRatio":h(o)||(this.aspectRatio=NaN);break;case"initialAspectRatio":h(o)||(this.initialAspectRatio=NaN);break;case"initialCoverage":(!h(o)||o>1)&&(this.initialCoverage=NaN);break;case"keyboard":this.$nextTick((()=>{if(this.$canvas)if(o){if(!this.$onDocumentKeyDown){this.$onDocumentKeyDown=this.$handleKeyDown.bind(this);i(this.ownerDocument,s,this.$onDocumentKeyDown)}}else if(this.$onDocumentKeyDown){a(this.ownerDocument,s,this.$onDocumentKeyDown);this.$onDocumentKeyDown=null}}));break;case"multiple":this.$nextTick((()=>{if(this.$canvas){const t=this.$getSelections();if(o){t.forEach((t=>{t.active=false}));this.active=true;this.$emit(e,{x:this.x,y:this.y,width:this.width,height:this.height})}else{this.active=false;t.slice(1).forEach((t=>{this.$removeSelection(t)}))}}}));break}}}connectedCallback(){super.connectedCallback();const t=this.closest(this.$getTagNameOf(n));if(t){this.$canvas=t;this.$setStyles({position:"absolute",transform:`translate(${this.x}px, ${this.y}px)`});this.hidden||this.$render();const{initialCoverage:e,parentElement:s}=this;if(h(e)&&s){const t=this.aspectRatio||this.initialAspectRatio;const{offsetWidth:i,offsetHeight:a}=s;let n=i*e;let r=a*e;h(t)&&({width:n,height:r}=o({aspectRatio:t,width:n,height:r}));this.$change(this.x,this.y,n,r);this.$center()}this.$onCanvasActionStart=this.$handleActionStart.bind(this);this.$onCanvasActionEnd=this.$handleActionEnd.bind(this);this.$onCanvasAction=this.$handleAction.bind(this);i(t,r,this.$onCanvasActionStart);i(t,c,this.$onCanvasActionStart);i(t,l,this.$onCanvasAction)}else this.$render()}disconnectedCallback(){const{$canvas:t}=this;if(t){if(this.$onCanvasActionStart){a(t,r,this.$onCanvasActionStart);this.$onCanvasActionStart=null}if(this.$onCanvasActionEnd){a(t,c,this.$onCanvasActionEnd);this.$onCanvasActionEnd=null}if(this.$onCanvasAction){a(t,l,this.$onCanvasAction);this.$onCanvasAction=null}}super.disconnectedCallback()}$getSelections(){let t=[];this.parentElement&&(t=Array.from(this.parentElement.querySelectorAll(this.$getTagNameOf(d))));return t}$createSelection(){const t=this.cloneNode(true);this.hasAttribute("id")&&t.removeAttribute("id");this.active=false;this.parentElement&&this.parentElement.insertBefore(t,this.nextSibling);return t}$removeSelection(t=this){if(this.parentElement){const i=this.$getSelections();if(i.length>1){const s=i.indexOf(t);const a=i[s+1]||i[s-1];if(a){t.active=false;this.parentElement.removeChild(t);a.active=true;a.$emit(e,{x:a.x,y:a.y,width:a.width,height:a.height})}}else{this.$reset();this.hidden=true}}}$handleActionStart(t){var i,s;const a=null===(s=null===(i=t.detail)||void 0===i?void 0:i.relatedEvent)||void 0===s?void 0:s.target;this.$action="";this.$actionStartTarget=a;if(!this.hidden&&this.multiple&&!this.active&&a===this&&this.parentElement){this.$getSelections().forEach((t=>{t.active=false}));this.active=true;this.$emit(e,{x:this.x,y:this.y,width:this.width,height:this.height})}}$handleAction(t){const{currentTarget:e,detail:i}=t;if(e&&i){const{relatedEvent:s}=i;let{action:a}=i;if(!a&&this.multiple){a=this.$action||(null===s||void 0===s?void 0:s.target.action);this.$action=a}if(!a||this.hidden&&a!==f||this.multiple&&!this.active&&a!==$)return;const n=i.endX-i.startX;const o=i.endY-i.startY;const{width:r,height:c}=this;let{aspectRatio:l}=this;!h(l)&&t.shiftKey&&(l=h(r)&&h(c)?r/c:1);switch(a){case f:{const{$canvas:t}=this;const s=u(e);(this.multiple&&!this.hidden?this.$createSelection():this).$change(i.startX-s.left,i.startY-s.top,n,o,l);a=p;n<0?o>0?a=m:o<0&&(a=g):n>0&&o<0&&(a=b);t&&(t.$action=a);break}case v:this.movable&&this.$actionStartTarget&&this.contains(this.$actionStartTarget)&&this.$move(n,o);break;case $:if(s&&this.zoomable){const t=u(e);this.$zoom(i.scale,s.pageX-t.left,s.pageY-t.top)}break;default:this.$resize(a,n,o,l)}}}$handleActionEnd(){this.$action="";this.$actionStartTarget=null}$handleKeyDown(t){if(!(this.hidden||!this.keyboard||this.multiple&&!this.active||t.defaultPrevented))switch(t.key){case"Backspace":if(t.metaKey){t.preventDefault();this.$removeSelection()}break;case"Delete":t.preventDefault();this.$removeSelection();break;case"ArrowLeft":t.preventDefault();this.$move(-1,0);break;case"ArrowRight":t.preventDefault();this.$move(1,0);break;case"ArrowUp":t.preventDefault();this.$move(0,-1);break;case"ArrowDown":t.preventDefault();this.$move(0,1);break;case"+":t.preventDefault();this.$zoom(.1);break;case"-":t.preventDefault();this.$zoom(-.1);break}}
/**
     * Aligns the selection to the center of its parent element.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$center(){const{parentElement:t}=this;if(!t)return this;const e=(t.offsetWidth-this.width)/2;const i=(t.offsetHeight-this.height)/2;return this.$change(e,i)}
/**
     * Moves the selection.
     * @param {number} x The moving distance in the horizontal direction.
     * @param {number} [y] The moving distance in the vertical direction.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$move(t,e=t){return this.$moveTo(this.x+t,this.y+e)}
/**
     * Moves the selection to a specific position.
     * @param {number} x The new position in the horizontal direction.
     * @param {number} [y] The new position in the vertical direction.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$moveTo(t,e=t){return this.movable?this.$change(t,e):this}
/**
     * Adjusts the size the selection on a specific side or corner.
     * @param {string} action Indicates the side or corner to resize.
     * @param {number} [offsetX] The horizontal offset of the specific side or corner.
     * @param {number} [offsetY] The vertical offset of the specific side or corner.
     * @param {number} [aspectRatio] The aspect ratio for computing the new size if it is necessary.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$resize(t,e=0,i=0,s=this.aspectRatio){if(!this.resizable)return this;const a=h(s);const{$canvas:n}=this;let{x:o,y:r,width:c,height:l}=this;switch(t){case A:r+=i;l-=i;if(l<0){t=k;l=-l;r-=l}if(a){e=i*s;o+=e/2;c-=e;if(c<0){c=-c;o-=c}}break;case y:c+=e;if(c<0){t=w;c=-c;o-=c}if(a){i=e/s;r-=i/2;l+=i;if(l<0){l=-l;r-=l}}break;case k:l+=i;if(l<0){t=A;l=-l;r-=l}if(a){e=i*s;o-=e/2;c+=e;if(c<0){c=-c;o-=c}}break;case w:o+=e;c-=e;if(c<0){t=y;c=-c;o-=c}if(a){i=e/s;r+=i/2;l-=i;if(l<0){l=-l;r-=l}}break;case b:a&&(i=-e/s);r+=i;l-=i;c+=e;if(c<0&&l<0){t=m;c=-c;l=-l;o-=c;r-=l}else if(c<0){t=g;c=-c;o-=c}else if(l<0){t=p;l=-l;r-=l}break;case g:a&&(i=e/s);o+=e;r+=i;c-=e;l-=i;if(c<0&&l<0){t=p;c=-c;l=-l;o-=c;r-=l}else if(c<0){t=b;c=-c;o-=c}else if(l<0){t=m;l=-l;r-=l}break;case p:a&&(i=e/s);c+=e;l+=i;if(c<0&&l<0){t=g;c=-c;l=-l;o-=c;r-=l}else if(c<0){t=m;c=-c;o-=c}else if(l<0){t=b;l=-l;r-=l}break;case m:a&&(i=-e/s);o+=e;c-=e;l+=i;if(c<0&&l<0){t=b;c=-c;l=-l;o-=c;r-=l}else if(c<0){t=p;c=-c;o-=c}else if(l<0){t=g;l=-l;r-=l}break}n&&n.$setAction(t);return this.$change(o,r,c,l)}
/**
     * Zooms the selection.
     * @param {number} scale The zoom factor. Positive numbers for zooming in, and negative numbers for zooming out.
     * @param {number} [x] The zoom origin in the horizontal, defaults to the center of the selection.
     * @param {number} [y] The zoom origin in the vertical, defaults to the center of the selection.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$zoom(t,e,i){if(!this.zoomable||0===t)return this;t<0?t=1/(1-t):t+=1;const{width:s,height:a}=this;const h=s*t;const n=a*t;let o=this.x;let r=this.y;if(C(e)&&C(i)){o-=(h-s)*((e-this.x)/s);r-=(n-a)*((i-this.y)/a)}else{o-=(h-s)/2;r-=(n-a)/2}return this.$change(o,r,h,n)}
/**
     * Changes the position and/or size of the selection.
     * @param {number} x The new position in the horizontal direction.
     * @param {number} y The new position in the vertical direction.
     * @param {number} [width] The new width.
     * @param {number} [height] The new height.
     * @param {number} [aspectRatio] The new aspect ratio for this change only.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$change(t,i,s=this.width,a=this.height,n=this.aspectRatio){if(!C(t)||!C(i)||!C(s)||!C(a))return this;if(!this.precise){t=Math.round(t);i=Math.round(i);s=Math.round(s);a=Math.round(a)}if(t===this.x&&i===this.y&&s===this.width&&a===this.height)return this;this.hidden&&(this.hidden=false);h(n)&&({width:s,height:a}=o({aspectRatio:n,width:s,height:a},"cover"));if(false===this.$emit(e,{x:t,y:i,width:s,height:a}))return this;this.x=t;this.y=i;this.width=s;this.height=a;return this.$render()}
/**
     * Resets the selection to its initial position and size.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$reset(){return this.$change(0,0,0,0)}
/**
     * Refreshes the position or size of the selection.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$render(){return this.$setStyles({transform:`translate(${this.x}px, ${this.y}px)`,width:this.width,height:this.height})}
/**
     * Generates a real canvas element, with the image (selected area only) draw into if there is one.
     * @param {object} [options] The available options.
     * @param {number} [options.width] The width of the canvas.
     * @param {number} [options.height] The height of the canvas.
     * @param {Function} [options.beforeDraw] The function called before drawing the image onto the canvas.
     * @returns {Promise} Returns a promise that resolves to the generated canvas element.
     */$toCanvas(t){return new Promise(((e,i)=>{if(!this.isConnected){i(new Error("The current element is not connected to the DOM."));return}const s=document.createElement("canvas");let{width:a,height:n}=this;let r=1;if(S(t)&&(h(t.width)||h(t.height))){({width:a,height:n}=o({aspectRatio:a/n,width:t.width,height:t.height}));r=a/this.width}s.width=a;s.height=n;if(!this.$canvas){e(s);return}const c=this.$canvas.querySelector(this.$getTagNameOf(x));c?c.$ready().then((i=>{const h=s.getContext("2d");if(h){const[e,o,l,d,f,$]=c.$getTransform();const u=-this.x;const v=-this.y;const p=(u*d-l*v)/(e*d-l*o);const m=(v-o*p)/d;let g=e*p+l*m+f;let b=o*p+d*m+$;let w=i.naturalWidth;let y=i.naturalHeight;if(1!==r){g*=r;b*=r;w*=r;y*=r}const k=w/2;const A=y/2;h.fillStyle="transparent";h.fillRect(0,0,a,n);S(t)&&D(t.beforeDraw)&&t.beforeDraw.call(this,h,s);h.save();h.translate(k,A);h.transform(e,o,l,d,g,b);h.translate(-k,-A);h.drawImage(i,0,0,w,y);h.restore()}e(s)})).catch(i):e(s)}))}}CropperSelection.$name=d;CropperSelection.$version="2.0.0-beta.4";export{CropperSelection as default};

